/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IApiClient {
    cartGet(): Observable<string[]>;
    cartPost(value: string): Observable<void>;
    cartGet(id: number): Observable<string>;
    cartPut(id: number, value: string): Observable<void>;
    cartDelete(id: number): Observable<void>;
    foodGet(): Observable<FoodGroupByTypeDto[]>;
    foodPost(newFood: FoodCreateDto): Observable<void>;
    foodGet(id: string): Observable<FoodDetailsDto>;
    foodPut(id: string, newFood: FoodCreateDto): Observable<void>;
    foodDelete(id: string): Observable<void>;
}

@Injectable()
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    cartGet(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartGet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processCartGet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    cartPost(value: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCartPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    cartGet(id: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartGet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCartGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    cartPut(id: number, value: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCartPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    cartDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCartDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    foodGet(): Observable<FoodGroupByTypeDto[]> {
        let url_ = this.baseUrl + "/api/Food";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoodGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoodGet(<any>response_);
                } catch (e) {
                    return <Observable<FoodGroupByTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodGroupByTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFoodGet(response: HttpResponseBase): Observable<FoodGroupByTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FoodGroupByTypeDto.fromJS(item, _mappings));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodGroupByTypeDto[]>(<any>null);
    }

    foodPost(newFood: FoodCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFood);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoodPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoodPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFoodPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    foodGet(id: string): Observable<FoodDetailsDto> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoodGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoodGet(<any>response_);
                } catch (e) {
                    return <Observable<FoodDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processFoodGet(response: HttpResponseBase): Observable<FoodDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FoodDetailsDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodDetailsDto>(<any>null);
    }

    foodPut(id: string, newFood: FoodCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFood);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoodPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoodPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFoodPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    foodDelete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoodDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoodDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFoodDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IUserClient {
    authenticate(model: AuthenticateRequestDto): Observable<FileResponse>;
}

@Injectable()
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    authenticate(model: AuthenticateRequestDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/User/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IClient {
    user(): Observable<FileResponse>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    user(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUser(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export class FoodGroupByTypeDto implements IFoodGroupByTypeDto {
    category!: number;
    foods!: FoodDto[] | undefined;

    constructor(data?: IFoodGroupByTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.category = _data["category"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FoodGroupByTypeDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodGroupByTypeDto>(data, _mappings, FoodGroupByTypeDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodGroupByTypeDto {
    category: number;
    foods: FoodDto[] | undefined;
}

export class FoodDto implements IFoodDto {
    id!: string;
    name!: string | undefined;
    price!: number;
    rating!: number;
    isAvailable!: boolean;
    description!: string | undefined;
    foodAllergens!: FoodAllergen[] | undefined;
    foodCategories!: number | undefined;

    constructor(data?: IFoodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.rating = _data["rating"];
            this.isAvailable = _data["isAvailable"];
            this.description = _data["description"];
            if (Array.isArray(_data["foodAllergens"])) {
                this.foodAllergens = [] as any;
                for (let item of _data["foodAllergens"])
                    this.foodAllergens!.push(FoodAllergen.fromJS(item, _mappings));
            }
            this.foodCategories = _data["foodCategories"];
        }
    }

    static fromJS(data: any, _mappings?: any): FoodDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodDto>(data, _mappings, FoodDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["rating"] = this.rating;
        data["isAvailable"] = this.isAvailable;
        data["description"] = this.description;
        if (Array.isArray(this.foodAllergens)) {
            data["foodAllergens"] = [];
            for (let item of this.foodAllergens)
                data["foodAllergens"].push(item.toJSON());
        }
        data["foodCategories"] = this.foodCategories;
        return data; 
    }
}

export interface IFoodDto {
    id: string;
    name: string | undefined;
    price: number;
    rating: number;
    isAvailable: boolean;
    description: string | undefined;
    foodAllergens: FoodAllergen[] | undefined;
    foodCategories: number | undefined;
}

export class Base implements IBase {
    createTime!: moment.Moment;
    modifyTime!: moment.Moment;
    isDelete!: boolean;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.createTime = _data["createTime"] ? moment.parseZone(_data["createTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? moment.parseZone(_data["modifyTime"].toString()) : <any>undefined;
            this.isDelete = _data["isDelete"];
        }
    }

    static fromJS(data: any, _mappings?: any): Base {
        data = typeof data === 'object' ? data : {};
        return createInstance<Base>(data, _mappings, Base);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createTime"] = this.createTime ? this.createTime.toISOString(true) : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString(true) : <any>undefined;
        data["isDelete"] = this.isDelete;
        return data; 
    }
}

export interface IBase {
    createTime: moment.Moment;
    modifyTime: moment.Moment;
    isDelete: boolean;
}

export class FoodAllergen extends Base implements IFoodAllergen {
    id!: string;
    food!: Food | undefined;
    foodId!: string;
    allergen!: Allergen;

    constructor(data?: IFoodAllergen) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.food = _data["food"] ? Food.fromJS(_data["food"], _mappings) : <any>undefined;
            this.foodId = _data["foodId"];
            this.allergen = _data["allergen"];
        }
    }

    static fromJS(data: any, _mappings?: any): FoodAllergen {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodAllergen>(data, _mappings, FoodAllergen);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["food"] = this.food ? this.food.toJSON() : <any>undefined;
        data["foodId"] = this.foodId;
        data["allergen"] = this.allergen;
        super.toJSON(data);
        return data; 
    }
}

export interface IFoodAllergen extends IBase {
    id: string;
    food: Food | undefined;
    foodId: string;
    allergen: Allergen;
}

export class Food extends Base implements IFood {
    id!: string;
    name!: string | undefined;
    price!: number;
    category!: FoodCategories;
    rating!: number;
    isAvailable!: boolean;
    description!: string | undefined;
    menu!: Menu | undefined;
    menuId!: string;
    comments!: Comment[] | undefined;
    foodAllergens!: FoodAllergen[] | undefined;
    order!: Order | undefined;
    orderId!: string | undefined;

    constructor(data?: IFood) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.category = _data["category"];
            this.rating = _data["rating"];
            this.isAvailable = _data["isAvailable"];
            this.description = _data["description"];
            this.menu = _data["menu"] ? Menu.fromJS(_data["menu"], _mappings) : <any>undefined;
            this.menuId = _data["menuId"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["foodAllergens"])) {
                this.foodAllergens = [] as any;
                for (let item of _data["foodAllergens"])
                    this.foodAllergens!.push(FoodAllergen.fromJS(item, _mappings));
            }
            this.order = _data["order"] ? Order.fromJS(_data["order"], _mappings) : <any>undefined;
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any, _mappings?: any): Food {
        data = typeof data === 'object' ? data : {};
        return createInstance<Food>(data, _mappings, Food);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["category"] = this.category;
        data["rating"] = this.rating;
        data["isAvailable"] = this.isAvailable;
        data["description"] = this.description;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuId"] = this.menuId;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.foodAllergens)) {
            data["foodAllergens"] = [];
            for (let item of this.foodAllergens)
                data["foodAllergens"].push(item.toJSON());
        }
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["orderId"] = this.orderId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFood extends IBase {
    id: string;
    name: string | undefined;
    price: number;
    category: FoodCategories;
    rating: number;
    isAvailable: boolean;
    description: string | undefined;
    menu: Menu | undefined;
    menuId: string;
    comments: Comment[] | undefined;
    foodAllergens: FoodAllergen[] | undefined;
    order: Order | undefined;
    orderId: string | undefined;
}

export enum FoodCategories {
    Soup = 1,
    Meat = 2,
}

export class Menu extends Base implements IMenu {
    id!: string;
    name!: string | undefined;
    foods!: Food[] | undefined;
    restaurant!: Restaurant | undefined;
    restaurantId!: string;

    constructor(data?: IMenu) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(Food.fromJS(item, _mappings));
            }
            this.restaurant = _data["restaurant"] ? Restaurant.fromJS(_data["restaurant"], _mappings) : <any>undefined;
            this.restaurantId = _data["restaurantId"];
        }
    }

    static fromJS(data: any, _mappings?: any): Menu {
        data = typeof data === 'object' ? data : {};
        return createInstance<Menu>(data, _mappings, Menu);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["restaurant"] = this.restaurant ? this.restaurant.toJSON() : <any>undefined;
        data["restaurantId"] = this.restaurantId;
        super.toJSON(data);
        return data; 
    }
}

export interface IMenu extends IBase {
    id: string;
    name: string | undefined;
    foods: Food[] | undefined;
    restaurant: Restaurant | undefined;
    restaurantId: string;
}

export class Restaurant extends Base implements IRestaurant {
    id!: string;
    name!: string | undefined;
    tables!: Table[] | undefined;
    employees!: MyUser[] | undefined;
    address!: string | undefined;
    email!: string | undefined;
    menu!: Menu | undefined;
    menuId!: string | undefined;
    dayOfWeekOpenTimes!: DayOfWeekOpenTimes[] | undefined;

    constructor(data?: IRestaurant) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["tables"])) {
                this.tables = [] as any;
                for (let item of _data["tables"])
                    this.tables!.push(Table.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(MyUser.fromJS(item, _mappings));
            }
            this.address = _data["address"];
            this.email = _data["email"];
            this.menu = _data["menu"] ? Menu.fromJS(_data["menu"], _mappings) : <any>undefined;
            this.menuId = _data["menuId"];
            if (Array.isArray(_data["dayOfWeekOpenTimes"])) {
                this.dayOfWeekOpenTimes = [] as any;
                for (let item of _data["dayOfWeekOpenTimes"])
                    this.dayOfWeekOpenTimes!.push(DayOfWeekOpenTimes.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Restaurant {
        data = typeof data === 'object' ? data : {};
        return createInstance<Restaurant>(data, _mappings, Restaurant);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item.toJSON());
        }
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["address"] = this.address;
        data["email"] = this.email;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuId"] = this.menuId;
        if (Array.isArray(this.dayOfWeekOpenTimes)) {
            data["dayOfWeekOpenTimes"] = [];
            for (let item of this.dayOfWeekOpenTimes)
                data["dayOfWeekOpenTimes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRestaurant extends IBase {
    id: string;
    name: string | undefined;
    tables: Table[] | undefined;
    employees: MyUser[] | undefined;
    address: string | undefined;
    email: string | undefined;
    menu: Menu | undefined;
    menuId: string | undefined;
    dayOfWeekOpenTimes: DayOfWeekOpenTimes[] | undefined;
}

export class Table extends Base implements ITable {
    id!: string;
    number!: number;
    restaurantId!: string;
    reservationId!: string;
    reservation!: Reservation | undefined;
    userId!: string | undefined;
    restaurant!: Restaurant | undefined;

    constructor(data?: ITable) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.restaurantId = _data["restaurantId"];
            this.reservationId = _data["reservationId"];
            this.reservation = _data["reservation"] ? Reservation.fromJS(_data["reservation"], _mappings) : <any>undefined;
            this.userId = _data["userId"];
            this.restaurant = _data["restaurant"] ? Restaurant.fromJS(_data["restaurant"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Table {
        data = typeof data === 'object' ? data : {};
        return createInstance<Table>(data, _mappings, Table);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["restaurantId"] = this.restaurantId;
        data["reservationId"] = this.reservationId;
        data["reservation"] = this.reservation ? this.reservation.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["restaurant"] = this.restaurant ? this.restaurant.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITable extends IBase {
    id: string;
    number: number;
    restaurantId: string;
    reservationId: string;
    reservation: Reservation | undefined;
    userId: string | undefined;
    restaurant: Restaurant | undefined;
}

export class Reservation extends Base implements IReservation {
    id!: string;
    from!: moment.Moment;
    to!: moment.Moment;
    tableId!: string;
    user!: MyUser | undefined;
    userId!: string | undefined;
    table!: Table | undefined;
    orders!: Order[] | undefined;

    constructor(data?: IReservation) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.from = _data["from"] ? moment.parseZone(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment.parseZone(_data["to"].toString()) : <any>undefined;
            this.tableId = _data["tableId"];
            this.user = _data["user"] ? MyUser.fromJS(_data["user"], _mappings) : <any>undefined;
            this.userId = _data["userId"];
            this.table = _data["table"] ? Table.fromJS(_data["table"], _mappings) : <any>undefined;
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Reservation {
        data = typeof data === 'object' ? data : {};
        return createInstance<Reservation>(data, _mappings, Reservation);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["from"] = this.from ? this.from.toISOString(true) : <any>undefined;
        data["to"] = this.to ? this.to.toISOString(true) : <any>undefined;
        data["tableId"] = this.tableId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IReservation extends IBase {
    id: string;
    from: moment.Moment;
    to: moment.Moment;
    tableId: string;
    user: MyUser | undefined;
    userId: string | undefined;
    table: Table | undefined;
    orders: Order[] | undefined;
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id!: string | undefined;
    userName!: string | undefined;
    normalizedUserName!: string | undefined;
    email!: string | undefined;
    normalizedEmail!: string | undefined;
    emailConfirmed!: boolean;
    passwordHash!: string | undefined;
    securityStamp!: string | undefined;
    concurrencyStamp!: string | undefined;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd!: moment.Moment | undefined;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment.parseZone(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserOfString>(data, _mappings, IdentityUserOfString);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString(true) : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IIdentityUserOfString {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
    }

    static fromJS(data: any, _mappings?: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUser>(data, _mappings, IdentityUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class MyUser extends IdentityUser implements IMyUser {
    picture!: string | undefined;
    title!: string | undefined;
    restaurant!: Restaurant | undefined;
    restaurantId!: string | undefined;
    reservationId!: string | undefined;
    reservation!: Reservation | undefined;
    tables!: Table[] | undefined;
    comments!: Comment[] | undefined;

    constructor(data?: IMyUser) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.picture = _data["picture"];
            this.title = _data["title"];
            this.restaurant = _data["restaurant"] ? Restaurant.fromJS(_data["restaurant"], _mappings) : <any>undefined;
            this.restaurantId = _data["restaurantId"];
            this.reservationId = _data["reservationId"];
            this.reservation = _data["reservation"] ? Reservation.fromJS(_data["reservation"], _mappings) : <any>undefined;
            if (Array.isArray(_data["tables"])) {
                this.tables = [] as any;
                for (let item of _data["tables"])
                    this.tables!.push(Table.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MyUser {
        data = typeof data === 'object' ? data : {};
        return createInstance<MyUser>(data, _mappings, MyUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["picture"] = this.picture;
        data["title"] = this.title;
        data["restaurant"] = this.restaurant ? this.restaurant.toJSON() : <any>undefined;
        data["restaurantId"] = this.restaurantId;
        data["reservationId"] = this.reservationId;
        data["reservation"] = this.reservation ? this.reservation.toJSON() : <any>undefined;
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMyUser extends IIdentityUser {
    picture: string | undefined;
    title: string | undefined;
    restaurant: Restaurant | undefined;
    restaurantId: string | undefined;
    reservationId: string | undefined;
    reservation: Reservation | undefined;
    tables: Table[] | undefined;
    comments: Comment[] | undefined;
}

export class Comment extends Base implements IComment {
    id!: string;
    foodId!: string;
    myUserId!: string | undefined;
    commentContent!: string | undefined;

    constructor(data?: IComment) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.foodId = _data["foodId"];
            this.myUserId = _data["myUserId"];
            this.commentContent = _data["commentContent"];
        }
    }

    static fromJS(data: any, _mappings?: any): Comment {
        data = typeof data === 'object' ? data : {};
        return createInstance<Comment>(data, _mappings, Comment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foodId"] = this.foodId;
        data["myUserId"] = this.myUserId;
        data["commentContent"] = this.commentContent;
        super.toJSON(data);
        return data; 
    }
}

export interface IComment extends IBase {
    id: string;
    foodId: string;
    myUserId: string | undefined;
    commentContent: string | undefined;
}

export class Order extends Base implements IOrder {
    id!: string;
    totalPrice!: number;
    comment!: string | undefined;
    orderTime!: moment.Moment;
    foods!: Food[] | undefined;
    reservation!: Reservation | undefined;
    reservationId!: string;

    constructor(data?: IOrder) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.totalPrice = _data["totalPrice"];
            this.comment = _data["comment"];
            this.orderTime = _data["orderTime"] ? moment.parseZone(_data["orderTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(Food.fromJS(item, _mappings));
            }
            this.reservation = _data["reservation"] ? Reservation.fromJS(_data["reservation"], _mappings) : <any>undefined;
            this.reservationId = _data["reservationId"];
        }
    }

    static fromJS(data: any, _mappings?: any): Order {
        data = typeof data === 'object' ? data : {};
        return createInstance<Order>(data, _mappings, Order);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalPrice"] = this.totalPrice;
        data["comment"] = this.comment;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString(true) : <any>undefined;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["reservation"] = this.reservation ? this.reservation.toJSON() : <any>undefined;
        data["reservationId"] = this.reservationId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOrder extends IBase {
    id: string;
    totalPrice: number;
    comment: string | undefined;
    orderTime: moment.Moment;
    foods: Food[] | undefined;
    reservation: Reservation | undefined;
    reservationId: string;
}

export class DayOfWeekOpenTimes extends Base implements IDayOfWeekOpenTimes {
    id!: string;
    restaurantId!: string;
    dayOfWeek!: DayOfWeek;
    openTimes!: OpenTime | undefined;

    constructor(data?: IDayOfWeekOpenTimes) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.restaurantId = _data["restaurantId"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.openTimes = _data["openTimes"] ? OpenTime.fromJS(_data["openTimes"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): DayOfWeekOpenTimes {
        data = typeof data === 'object' ? data : {};
        return createInstance<DayOfWeekOpenTimes>(data, _mappings, DayOfWeekOpenTimes);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantId"] = this.restaurantId;
        data["dayOfWeek"] = this.dayOfWeek;
        data["openTimes"] = this.openTimes ? this.openTimes.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDayOfWeekOpenTimes extends IBase {
    id: string;
    restaurantId: string;
    dayOfWeek: DayOfWeek;
    openTimes: OpenTime | undefined;
}

export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

export class OpenTime extends Base implements IOpenTime {
    id!: string;
    from!: moment.Moment;
    to!: moment.Moment;

    constructor(data?: IOpenTime) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.from = _data["from"] ? moment.parseZone(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment.parseZone(_data["to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OpenTime {
        data = typeof data === 'object' ? data : {};
        return createInstance<OpenTime>(data, _mappings, OpenTime);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["from"] = this.from ? this.from.toISOString(true) : <any>undefined;
        data["to"] = this.to ? this.to.toISOString(true) : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IOpenTime extends IBase {
    id: string;
    from: moment.Moment;
    to: moment.Moment;
}

export enum Allergen {
    Gluten = 0,
    Laktoz = 1,
}

export class FoodDetailsDto implements IFoodDetailsDto {
    id!: string;
    name!: string | undefined;
    price!: number;
    category!: number;
    rating!: number;
    description!: string | undefined;
    comments!: Comment[] | undefined;
    foodAllergens!: FoodAllergen[] | undefined;

    constructor(data?: IFoodDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.category = _data["category"];
            this.rating = _data["rating"];
            this.description = _data["description"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["foodAllergens"])) {
                this.foodAllergens = [] as any;
                for (let item of _data["foodAllergens"])
                    this.foodAllergens!.push(FoodAllergen.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FoodDetailsDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodDetailsDto>(data, _mappings, FoodDetailsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["category"] = this.category;
        data["rating"] = this.rating;
        data["description"] = this.description;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.foodAllergens)) {
            data["foodAllergens"] = [];
            for (let item of this.foodAllergens)
                data["foodAllergens"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodDetailsDto {
    id: string;
    name: string | undefined;
    price: number;
    category: number;
    rating: number;
    description: string | undefined;
    comments: Comment[] | undefined;
    foodAllergens: FoodAllergen[] | undefined;
}

export class FoodCreateDto implements IFoodCreateDto {
    id!: string | undefined;
    name!: string | undefined;
    price!: number;
    category!: FoodCategories;
    description!: string | undefined;
    menuId!: string;
    foodAllergens!: Allergen[] | undefined;

    constructor(data?: IFoodCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.menuId = _data["menuId"];
            if (Array.isArray(_data["foodAllergens"])) {
                this.foodAllergens = [] as any;
                for (let item of _data["foodAllergens"])
                    this.foodAllergens!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FoodCreateDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodCreateDto>(data, _mappings, FoodCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["category"] = this.category;
        data["description"] = this.description;
        data["menuId"] = this.menuId;
        if (Array.isArray(this.foodAllergens)) {
            data["foodAllergens"] = [];
            for (let item of this.foodAllergens)
                data["foodAllergens"].push(item);
        }
        return data; 
    }
}

export interface IFoodCreateDto {
    id: string | undefined;
    name: string | undefined;
    price: number;
    category: FoodCategories;
    description: string | undefined;
    menuId: string;
    foodAllergens: Allergen[] | undefined;
}

export class AuthenticateRequestDto implements IAuthenticateRequestDto {
    username!: string;
    password!: string;

    constructor(data?: IAuthenticateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): AuthenticateRequestDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<AuthenticateRequestDto>(data, _mappings, AuthenticateRequestDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticateRequestDto {
    username: string;
    password: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}