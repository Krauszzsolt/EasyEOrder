/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICartClient {
    cart_Get(): Observable<CartDto>;
    cart_AddToCart(foodId: string): Observable<void>;
    cart_BuyCartContent(): Observable<void>;
    cart_RemoveFromCart(id: string): Observable<void>;
}

@Injectable()
export class CartClient implements ICartClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    cart_Get(): Observable<CartDto> {
        let url_ = this.baseUrl + "/api/Cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCart_Get(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCart_Get(<any>response_);
                } catch (e) {
                    return <Observable<CartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CartDto>><any>_observableThrow(response_);
        }));
    }

    protected processCart_Get(response: HttpResponseBase): Observable<CartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CartDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CartDto>(<any>null);
    }

    cart_AddToCart(foodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart/AddToCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(foodId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCart_AddToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCart_AddToCart(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCart_AddToCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    cart_BuyCartContent(): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart/Buy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCart_BuyCartContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCart_BuyCartContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCart_BuyCartContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    cart_RemoveFromCart(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Cart/RemoveFromCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCart_RemoveFromCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCart_RemoveFromCart(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCart_RemoveFromCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IFoodClient {
    food_GetAll(menuId: string, searchTerm: string | null, index: number, pageSize: number): Observable<PageableListOfFoodGroupByTypeDto>;
    food_Post(newFood: FoodCreateDto): Observable<void>;
    food_Get(id: string): Observable<FoodDetailsDto>;
    food_Put(id: string, newFood: FoodCreateDto): Observable<void>;
    food_Delete(id: string): Observable<void>;
}

@Injectable()
export class FoodClient implements IFoodClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    food_GetAll(menuId: string, searchTerm: string | null, index: number, pageSize: number): Observable<PageableListOfFoodGroupByTypeDto> {
        let url_ = this.baseUrl + "/api/Food?";
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined and cannot be null.");
        else
            url_ += "MenuId=" + encodeURIComponent("" + menuId) + "&";
        if (searchTerm === undefined)
            throw new Error("The parameter 'searchTerm' must be defined.");
        else if(searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined and cannot be null.");
        else
            url_ += "Index=" + encodeURIComponent("" + index) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFood_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFood_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<PageableListOfFoodGroupByTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageableListOfFoodGroupByTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processFood_GetAll(response: HttpResponseBase): Observable<PageableListOfFoodGroupByTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = PageableListOfFoodGroupByTypeDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageableListOfFoodGroupByTypeDto>(<any>null);
    }

    food_Post(newFood: FoodCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFood);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFood_Post(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFood_Post(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFood_Post(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    food_Get(id: string): Observable<FoodDetailsDto> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFood_Get(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFood_Get(<any>response_);
                } catch (e) {
                    return <Observable<FoodDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processFood_Get(response: HttpResponseBase): Observable<FoodDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FoodDetailsDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodDetailsDto>(<any>null);
    }

    food_Put(id: string, newFood: FoodCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFood);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFood_Put(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFood_Put(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFood_Put(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    food_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFood_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFood_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFood_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IRestaurantClient {
    restaurant_GetAllRestaurant(index: number, pageSize: number): Observable<PageableListOfRestaruantDTO>;
    restaurant_AddRestaurant(restaurant: CreateRestaurantDto): Observable<void>;
    restaurant_GetRestaurant(id: string): Observable<RestaruantDetailDto>;
    restaurant_EditRestaurant(id: string, restaurant: RestaruantDTO): Observable<void>;
    restaurant_Delete(id: string): Observable<void>;
}

@Injectable()
export class RestaurantClient implements IRestaurantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    restaurant_GetAllRestaurant(index: number, pageSize: number): Observable<PageableListOfRestaruantDTO> {
        let url_ = this.baseUrl + "/api/Restaurant?";
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined and cannot be null.");
        else
            url_ += "Index=" + encodeURIComponent("" + index) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurant_GetAllRestaurant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurant_GetAllRestaurant(<any>response_);
                } catch (e) {
                    return <Observable<PageableListOfRestaruantDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageableListOfRestaruantDTO>><any>_observableThrow(response_);
        }));
    }

    protected processRestaurant_GetAllRestaurant(response: HttpResponseBase): Observable<PageableListOfRestaruantDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = PageableListOfRestaruantDTO.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageableListOfRestaruantDTO>(<any>null);
    }

    restaurant_AddRestaurant(restaurant: CreateRestaurantDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restaurant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurant_AddRestaurant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurant_AddRestaurant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestaurant_AddRestaurant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    restaurant_GetRestaurant(id: string): Observable<RestaruantDetailDto> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurant_GetRestaurant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurant_GetRestaurant(<any>response_);
                } catch (e) {
                    return <Observable<RestaruantDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RestaruantDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processRestaurant_GetRestaurant(response: HttpResponseBase): Observable<RestaruantDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RestaruantDetailDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RestaruantDetailDto>(<any>null);
    }

    restaurant_EditRestaurant(id: string, restaurant: RestaruantDTO): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restaurant);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurant_EditRestaurant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurant_EditRestaurant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestaurant_EditRestaurant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    restaurant_Delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurant_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurant_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestaurant_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IUserClient {
    user_GetAll(): Observable<ApplicationUserDto[]>;
    user_Authenticate(model: LoginDto): Observable<ApplicationUserDto>;
    user_Register(model: RegisterDto): Observable<ApplicationUserDto>;
}

@Injectable()
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    user_GetAll(): Observable<ApplicationUserDto[]> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUser_GetAll(response: HttpResponseBase): Observable<ApplicationUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationUserDto.fromJS(item, _mappings));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDto[]>(<any>null);
    }

    user_Authenticate(model: LoginDto): Observable<ApplicationUserDto> {
        let url_ = this.baseUrl + "/api/User/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_Authenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_Authenticate(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUser_Authenticate(response: HttpResponseBase): Observable<ApplicationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDto>(<any>null);
    }

    user_Register(model: RegisterDto): Observable<ApplicationUserDto> {
        let url_ = this.baseUrl + "/api/User/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser_Register(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser_Register(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUser_Register(response: HttpResponseBase): Observable<ApplicationUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDto.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDto>(<any>null);
    }
}

export class CartDto implements ICartDto {
    id!: string;
    foods!: FoodDto[] | undefined;
    totalPrice!: number;
    comment!: string | undefined;
    orderTime!: moment.Moment;
    userId!: string | undefined;

    constructor(data?: ICartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodDto.fromJS(item, _mappings));
            }
            this.totalPrice = _data["totalPrice"];
            this.comment = _data["comment"];
            this.orderTime = _data["orderTime"] ? moment.parseZone(_data["orderTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any, _mappings?: any): CartDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<CartDto>(data, _mappings, CartDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        data["totalPrice"] = this.totalPrice;
        data["comment"] = this.comment;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString(true) : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ICartDto {
    id: string;
    foods: FoodDto[] | undefined;
    totalPrice: number;
    comment: string | undefined;
    orderTime: moment.Moment;
    userId: string | undefined;
}

export class FoodDto implements IFoodDto {
    id!: string;
    name!: string | undefined;
    price!: number;
    rating!: number;
    isAvailable!: boolean;
    description!: string | undefined;
    allergens!: Allergen[] | undefined;

    constructor(data?: IFoodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.rating = _data["rating"];
            this.isAvailable = _data["isAvailable"];
            this.description = _data["description"];
            if (Array.isArray(_data["allergens"])) {
                this.allergens = [] as any;
                for (let item of _data["allergens"])
                    this.allergens!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FoodDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodDto>(data, _mappings, FoodDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["rating"] = this.rating;
        data["isAvailable"] = this.isAvailable;
        data["description"] = this.description;
        if (Array.isArray(this.allergens)) {
            data["allergens"] = [];
            for (let item of this.allergens)
                data["allergens"].push(item);
        }
        return data; 
    }
}

export interface IFoodDto {
    id: string;
    name: string | undefined;
    price: number;
    rating: number;
    isAvailable: boolean;
    description: string | undefined;
    allergens: Allergen[] | undefined;
}

export enum Allergen {
    Gluten = 0,
    Laktoz = 1,
}

export class PageableListOfFoodGroupByTypeDto implements IPageableListOfFoodGroupByTypeDto {
    data!: FoodGroupByTypeDto[] | undefined;
    index!: number;
    pageSize!: number;
    count!: number;

    constructor(data?: IPageableListOfFoodGroupByTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FoodGroupByTypeDto.fromJS(item, _mappings));
            }
            this.index = _data["index"];
            this.pageSize = _data["pageSize"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any, _mappings?: any): PageableListOfFoodGroupByTypeDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<PageableListOfFoodGroupByTypeDto>(data, _mappings, PageableListOfFoodGroupByTypeDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["index"] = this.index;
        data["pageSize"] = this.pageSize;
        data["count"] = this.count;
        return data; 
    }
}

export interface IPageableListOfFoodGroupByTypeDto {
    data: FoodGroupByTypeDto[] | undefined;
    index: number;
    pageSize: number;
    count: number;
}

export class FoodGroupByTypeDto implements IFoodGroupByTypeDto {
    category!: number;
    foods!: FoodDto[] | undefined;

    constructor(data?: IFoodGroupByTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.category = _data["category"];
            if (Array.isArray(_data["foods"])) {
                this.foods = [] as any;
                for (let item of _data["foods"])
                    this.foods!.push(FoodDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FoodGroupByTypeDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodGroupByTypeDto>(data, _mappings, FoodGroupByTypeDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        if (Array.isArray(this.foods)) {
            data["foods"] = [];
            for (let item of this.foods)
                data["foods"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodGroupByTypeDto {
    category: number;
    foods: FoodDto[] | undefined;
}

export class FoodDetailsDto extends FoodDto implements IFoodDetailsDto {
    comments!: Comment[] | undefined;
    category!: number;

    constructor(data?: IFoodDetailsDto) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item, _mappings));
            }
            this.category = _data["category"];
        }
    }

    static fromJS(data: any, _mappings?: any): FoodDetailsDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodDetailsDto>(data, _mappings, FoodDetailsDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["category"] = this.category;
        super.toJSON(data);
        return data; 
    }
}

export interface IFoodDetailsDto extends IFoodDto {
    comments: Comment[] | undefined;
    category: number;
}

export class Base implements IBase {
    createTime!: moment.Moment;
    modifyTime!: moment.Moment;
    isDelete!: boolean;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.createTime = _data["createTime"] ? moment.parseZone(_data["createTime"].toString()) : <any>undefined;
            this.modifyTime = _data["modifyTime"] ? moment.parseZone(_data["modifyTime"].toString()) : <any>undefined;
            this.isDelete = _data["isDelete"];
        }
    }

    static fromJS(data: any, _mappings?: any): Base {
        data = typeof data === 'object' ? data : {};
        return createInstance<Base>(data, _mappings, Base);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createTime"] = this.createTime ? this.createTime.toISOString(true) : <any>undefined;
        data["modifyTime"] = this.modifyTime ? this.modifyTime.toISOString(true) : <any>undefined;
        data["isDelete"] = this.isDelete;
        return data; 
    }
}

export interface IBase {
    createTime: moment.Moment;
    modifyTime: moment.Moment;
    isDelete: boolean;
}

export class Comment extends Base implements IComment {
    id!: string;
    foodId!: string;
    myUserId!: string | undefined;
    commentContent!: string | undefined;

    constructor(data?: IComment) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.foodId = _data["foodId"];
            this.myUserId = _data["myUserId"];
            this.commentContent = _data["commentContent"];
        }
    }

    static fromJS(data: any, _mappings?: any): Comment {
        data = typeof data === 'object' ? data : {};
        return createInstance<Comment>(data, _mappings, Comment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foodId"] = this.foodId;
        data["myUserId"] = this.myUserId;
        data["commentContent"] = this.commentContent;
        super.toJSON(data);
        return data; 
    }
}

export interface IComment extends IBase {
    id: string;
    foodId: string;
    myUserId: string | undefined;
    commentContent: string | undefined;
}

export class FoodCreateDto extends FoodDto implements IFoodCreateDto {
    category!: FoodCategories;
    menuId!: string;

    constructor(data?: IFoodCreateDto) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.category = _data["category"];
            this.menuId = _data["menuId"];
        }
    }

    static fromJS(data: any, _mappings?: any): FoodCreateDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodCreateDto>(data, _mappings, FoodCreateDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["menuId"] = this.menuId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFoodCreateDto extends IFoodDto {
    category: FoodCategories;
    menuId: string;
}

export enum FoodCategories {
    Soup = 1,
    Meat = 2,
}

export class PageableListOfRestaruantDTO implements IPageableListOfRestaruantDTO {
    data!: RestaruantDTO[] | undefined;
    index!: number;
    pageSize!: number;
    count!: number;

    constructor(data?: IPageableListOfRestaruantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RestaruantDTO.fromJS(item, _mappings));
            }
            this.index = _data["index"];
            this.pageSize = _data["pageSize"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any, _mappings?: any): PageableListOfRestaruantDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<PageableListOfRestaruantDTO>(data, _mappings, PageableListOfRestaruantDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["index"] = this.index;
        data["pageSize"] = this.pageSize;
        data["count"] = this.count;
        return data; 
    }
}

export interface IPageableListOfRestaruantDTO {
    data: RestaruantDTO[] | undefined;
    index: number;
    pageSize: number;
    count: number;
}

export class RestaruantDTO implements IRestaruantDTO {
    id!: string;
    name!: string | undefined;
    address!: string | undefined;
    email!: string | undefined;
    menuId!: string;

    constructor(data?: IRestaruantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.email = _data["email"];
            this.menuId = _data["menuId"];
        }
    }

    static fromJS(data: any, _mappings?: any): RestaruantDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaruantDTO>(data, _mappings, RestaruantDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["email"] = this.email;
        data["menuId"] = this.menuId;
        return data; 
    }
}

export interface IRestaruantDTO {
    id: string;
    name: string | undefined;
    address: string | undefined;
    email: string | undefined;
    menuId: string;
}

export class RestaruantDetailDto extends RestaruantDTO implements IRestaruantDetailDto {
    dayOfWeekOpenTimes!: DayOfWeekOpenTimesDto[] | undefined;

    constructor(data?: IRestaruantDetailDto) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["dayOfWeekOpenTimes"])) {
                this.dayOfWeekOpenTimes = [] as any;
                for (let item of _data["dayOfWeekOpenTimes"])
                    this.dayOfWeekOpenTimes!.push(DayOfWeekOpenTimesDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RestaruantDetailDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaruantDetailDto>(data, _mappings, RestaruantDetailDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dayOfWeekOpenTimes)) {
            data["dayOfWeekOpenTimes"] = [];
            for (let item of this.dayOfWeekOpenTimes)
                data["dayOfWeekOpenTimes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRestaruantDetailDto extends IRestaruantDTO {
    dayOfWeekOpenTimes: DayOfWeekOpenTimesDto[] | undefined;
}

export class DayOfWeekOpenTimesDto implements IDayOfWeekOpenTimesDto {
    dayOfWeek!: DayOfWeek;
    openTimes!: OpenTimeDTO | undefined;

    constructor(data?: IDayOfWeekOpenTimesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.dayOfWeek = _data["dayOfWeek"];
            this.openTimes = _data["openTimes"] ? OpenTimeDTO.fromJS(_data["openTimes"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): DayOfWeekOpenTimesDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<DayOfWeekOpenTimesDto>(data, _mappings, DayOfWeekOpenTimesDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dayOfWeek"] = this.dayOfWeek;
        data["openTimes"] = this.openTimes ? this.openTimes.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDayOfWeekOpenTimesDto {
    dayOfWeek: DayOfWeek;
    openTimes: OpenTimeDTO | undefined;
}

export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

export class OpenTimeDTO implements IOpenTimeDTO {
    from!: moment.Moment;
    to!: moment.Moment;

    constructor(data?: IOpenTimeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.from = _data["from"] ? moment.parseZone(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? moment.parseZone(_data["to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OpenTimeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<OpenTimeDTO>(data, _mappings, OpenTimeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString(true) : <any>undefined;
        data["to"] = this.to ? this.to.toISOString(true) : <any>undefined;
        return data; 
    }
}

export interface IOpenTimeDTO {
    from: moment.Moment;
    to: moment.Moment;
}

export class CreateRestaurantDto extends RestaruantDTO implements ICreateRestaurantDto {
    dayOfWeekOpenTimes!: DayOfWeekOpenTimesDto[] | undefined;

    constructor(data?: ICreateRestaurantDto) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["dayOfWeekOpenTimes"])) {
                this.dayOfWeekOpenTimes = [] as any;
                for (let item of _data["dayOfWeekOpenTimes"])
                    this.dayOfWeekOpenTimes!.push(DayOfWeekOpenTimesDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CreateRestaurantDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateRestaurantDto>(data, _mappings, CreateRestaurantDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dayOfWeekOpenTimes)) {
            data["dayOfWeekOpenTimes"] = [];
            for (let item of this.dayOfWeekOpenTimes)
                data["dayOfWeekOpenTimes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateRestaurantDto extends IRestaruantDTO {
    dayOfWeekOpenTimes: DayOfWeekOpenTimesDto[] | undefined;
}

export class ApplicationUserDto implements IApplicationUserDto {
    id!: string | undefined;
    userName!: string | undefined;
    role!: string | undefined;
    token!: string | undefined;

    constructor(data?: IApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.role = _data["role"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any, _mappings?: any): ApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApplicationUserDto>(data, _mappings, ApplicationUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["role"] = this.role;
        data["token"] = this.token;
        return data; 
    }
}

export interface IApplicationUserDto {
    id: string | undefined;
    userName: string | undefined;
    role: string | undefined;
    token: string | undefined;
}

export class LoginDto implements ILoginDto {
    username!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginDto>(data, _mappings, LoginDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginDto {
    username: string;
    password: string;
}

export class RegisterDto implements IRegisterDto {
    username!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterDto>(data, _mappings, RegisterDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterDto {
    username: string;
    password: string;
    confirmPassword: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}